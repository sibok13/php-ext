<?php

// 5. Дан код:
class A {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
$a1 = new A();
$a2 = new A();
$a1->foo(); // 1
$a2->foo(); // 2
$a1->foo(); // 3
$a2->foo(); // 4

// Что он выведет на каждом шаге? Почему?

// ОТВЕТ: код выведет 1 2 3 4, так как $x статичная и доступна всем объектам, 
// созданным из класса A. При каждом вызове метода у объектов созданных из A
// статичная переменная x увеличивается на 1 и она общая для всех объектов.

// -----------------------------------------

// 6. Немного изменим п.5:
// Объясните результаты в этом случае.

class A02 {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B02 extends A02 {
}
$a1 = new A02();
$b1 = new B02();
$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2

// ОТВЕТ: В наследуемом классе B метод foo переопределен и в данном случае возникла своя статичная
// переменная x внутри нового класса B. В этом случае у каждого класса (и у А и у B) свои $x, соответственно
// свое независимое увеличение $x

// -----------------------------------------

// 7. *Дан код:
class A03 {
    public function foo() {
        static $x = 0;
        echo ++$x;
    }
}
class B03 extends A03 {
}
$a1 = new A03;
$b1 = new B03;
$a1->foo(); // 1
$b1->foo(); // 1
$a1->foo(); // 2
$b1->foo(); // 2

// Что он выведет на каждом шаге? Почему?

// ОТВЕТ: вывод аналогичен заданию 6. В данном случае, так как классам нет необходимости 
// передавать аргументы при создании экземпляров, то при создании объектов на основе этих классов
// результат между $a1 = new A и $a1 = new A() будет одинаковым.